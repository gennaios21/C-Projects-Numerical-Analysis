#include <stdio.h>
#include <stdlib.h>
#include <math.h>
#define pi M_PI


///////////////////// αποστασεις ρa=ra,R,za, γωνια φα=xa, φορτιο Q, σταθερα k
double ra=0.1;     
double xa=35.0*pi/180.0;
double R=0.05;
double za=0.4;
double Q=pow(10.0,-6.0);
double k=9.0*pow(10.0,9.0);
	
//////////////////////////////////////////// συνιστωσα E (με x=φ)
double E(double x){ 

	double A=pow(ra,2.0)+pow(R,2.0)+pow(za,2.0);
	double B=A-2*ra*R*cos(x-xa);
	
	double D=pow(ra,2.0)+pow(R,2.0)-2*ra*R*cos(x-xa);
	double C=k*Q*pow(D,0.5);
	
	return C/(2*pi*pow(B,1.5));
}

///////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////// main
int main() {
	
    
	int n=0;	           //n= αριθμος υποδιαστηματων του διαστηματος [a,β]
	int i,j;                  //i,j για τους 2 επαναληπτικους βρογχους
	double E1a,E2a,E3a, E1b,E2b,E3b, Ea,Eb;   //μεταβλητες Εα,Ε1α,Ε2α,E3a για Εz με βημα h, Εb,Ε1b,Ε2b,E3b για Ε με βημα h/2
	double a=0.0;        //αριστερο ακρο διαστηματος  α=0
	double b=2.0*pi;     //δεξί ακρο διαστηματος β=2π
	double h,h2;         //βημα h, h2=h/2
	double xi,xj;       //xi=a+i*h, xj=a+i*h2
	double error;       //σφαλμα
	
	do{
		n++;                //αυξηση αριθμου υποδιαστηματων κατα 1 καθε φορα
		printf("------- n=%d -------\n",n);          //εκτυπωση τρεχοντος n
	////////////////////////////////////////////////////////////////////////////////////////////// κωδικας για h
		h=(b-a)/n;                            //βημα h=(b-a)/n
		E1a=(h/3.0)*( E(a) + E(b) );         //χωριζω τον υπολογισμο σε 3 κομματια E1a,E2a,E3a, οπου Ε1α αφορα στα f(x0),f(xn) του κανονα Simpson
		E2a=0.0;
		E3a=0.0;
		Ea=0.0;
		
		for(i=1;i<=n-1;i=i+2){             //υπολογισμος των f(x1),f(x3),...,f(xn-1) του κανονα Simpson
			xi=a+i*h;
			E2a=E2a+E(xi);
		}
		
		for(i=2;i<=n-2;i=i+2){             //υπολογισμος των f(x2),f(x4),...,f(xn-2) του κανονα Simpson
			xi=a+i*h;
			E3a=E3a+E(xi);
		}
		
		
		E2a=4*(h/3.0)*E2a;                 
		E3a=2*(h/3.0)*E3a;
		
		Ea=E1a+E2a+E3a;                  //συνολικο πεδίο σε N/C
		Ea=Ea*pow(10.0,-3.0);              //μετατροπη σε kN/C
		printf("E = %.8f kN/C \n",Ea);          //εκτυπωση του πεδιου με βημα h
	///////////////////////////////////////////////////////////////////////////////////////////////// κωδικας για h/2		
		h2=h*0.5;                               //ομοιως η ιδια διαδικασια, για βημα h2=h/2
		E1b=(h2/3.0)*( E(a) + E(b) );         
		E2b=0.0;
		E3b=0.0;
		Eb=0.0;
		
		for(j=1;j<=2*n-1;j=j+2){             
			xj=a+j*h2;
			E2b=E2b+E(xj);
		}
		
		for(j=2;j<=2*n-2;j=j+2){             
			xj=a+j*h2;
			E3b=E3b+E(xj);
		}
		
		
		E2b=4*(h2/3.0)*E2b;
		E3b=2*(h2/3.0)*E3b;
		
		Eb=E1b+E2b+E3b;                  //συνολικο πεδίο σε N/C
		Eb=Eb*pow(10.0,-3.0);
		printf("E = %.8f kN/C \n\n",Eb);	  //εκτυπωση του πεδιου με βημα h/2
	//////////////////////////////////////////////////////////////////////////////////////
		error=fabs(Ea-Eb);                 //σφαλμα=απολυτη τιμη της διαφορας των 2 υπολογισμων του πεδιου Εz
		printf("error = %.8f \n\n",error);     //εκτυπωση σφαλματος
		
	}while(error>=0.5*pow(10.0,-8.0));                 //ακριβεια 8 δεκαδικων
	
	printf("Telikh timh E = %.8f kN/C \n",Ea);           //εκτυπωση τελικης τιμης του πεδιου
return;
}


