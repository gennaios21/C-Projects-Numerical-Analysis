#include <stdio.h>
#include <stdlib.h>
#include <math.h>

//////////////////////////////////////////////////////////////// f1,f2
double f1(double x1,double x2){           //f1
	return pow(x1,3)-3.0*x1*pow(x2,2)-1.0;
}

double f2(double x1,double x2){           //f2
	return 3.0*pow(x1,2)*x2-pow(x2,3);
}
//////////////////////////////////////////////////        // df1
double df1_x1(double x1,double x2){     //df1_x1
	return 3.0*pow(x1,2)-3.0*pow(x2,2);
}

double df1_x2(double x1,double x2){     //df1_x2
	return -6.0*x1*x2;
}
//////////////////////////////////////////////////         //df2
double df2_x1(double x1,double x2){   //df2_x1
	return 6.0*x2*x1;
}

double df2_x2(double x1,double x2){   //df2_x2
	return 3.0*pow(x1,2)-3.0*pow(x2,2);
}
//////////////////////////////////////////////////////////////// det 2x2
double det(double a11,double a12, double a21, double a22){
	return a11*a22-a12*a21;
}

////////////////////////////////////////////////////////////////////////////////// main
///////////////////////////////////////////////////////////////////////////////////////

int main(){
	double error,DET,DETdx1,DETdx2;  //μεταβλητες σφαλματος, οριζουσων Κραμερ
	double dx1,dx2; //διορθωσεις
	double x1,x2;
	double x01,x02; //βοθητικες μεταβλητες για ευρεση των αρχικων συνθηκων
	int i=0;
	int n,m;
	int yp=100;  //αριθμος υποδιαστηματων σε καθε αξονα
	double step=pow(yp,-1); //βημα σαρωσης διαστηματος
	
	for(n=0; n<=(2*yp);n++){  //σαρωση οριζοντιου αξονα
		for(m=0; m<=(2*yp) ;m++){  //σαρωση καθετου αξονα
		
			x1=-1.0+n*step; //αρχικες συνθηκες
			x2=-1.0+m*step; //αρχικες συνθηκες
			
			x01=x1; //αρχικες συνθηκες σε βοηθητικες μεταβλητες που καταληγουν σε ριζα
			x02=x2; //αρχικες συνθηκες σε βοηθητικες μεταβλητες που καταληγουν σε ριζα
			
			do{
					
				DET=det(df1_x1(x1,x2),df1_x2(x1,x2),df2_x1(x1,x2),df2_x2(x1,x2));  //οριζουσες Κραμερ
				DETdx1=det(-f1(x1,x2),df1_x2(x1,x2),-f2(x1,x2),df2_x2(x1,x2));  
				DETdx2=det(df1_x1(x1,x2),-f1(x1,x2),df2_x1(x1,x2),-f2(x1,x2));
				
				dx1=DETdx1/DET;   //μεθοδος Κραμερ
				dx2=DETdx2/DET;  
				
				x1=x1+dx1;  //επομενη προσεγγιση ριζας=προηγουμενη+διορθωση
				x2=x2+dx2;
				error=fabs(dx1) + fabs(dx2);  //συνολικο σφαλμα απο τις 2 διορθωσεις
				
				if (  f1(x1,x2)==f2(x1,x2)  ){		//οταν f1=f2=0 (μονο τοτε ισχυει f1=f2)	
					i++;		
					printf("\n i=%3d   Arxikes synthikes: {x01=%10.5f, x02=%10.5f}  |  x1=%10.5f  x2=%10.5f  f1=%10.5f  f2=%10.5f  error=%10.1e",
						i,x01,x02,x1,x2,f1(x1,x2),f2(x1,x2),error);	 //εκτυπωση ριζων, αρχικων συνθηκων,σφαλματος, f(x)=0 στην ριζα
					}
				}while(error>=0.5*pow(10.0,-5));  //ακριβεια 5 δεκαδικων
			}
		}
	printf("\n");
	return 0;
	
}
